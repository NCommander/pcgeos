/***********************************************************************
 *
 *	Copyright (c) Geoworks 1992 -- All Rights Reserved
 *
 * PROJECT:	  PC/GEOS
 * MODULE:	  ffDatabaseFields.goc
 * FILE:	  ffDatabaseFields.goc
 *
 * AUTHOR:  	  Jeremy Dashe : Jun 10, 1992
 *
 * DESCRIPTION:
 *	This file contains methods and functions for the flat file
 *	field classes.
 *
 * RCS STAMP:
 *	$Id: ffDatabaseFields.goc,v 1.1 97/04/04 18:03:08 newdeal Exp $
 *
 ***********************************************************************/

@include <stdapp.goh>
#include <geoworks.h>
#include <system.h>

#include <Ansi/stdio.h>
#include <Ansi/string.h>
#include <Ansi/ctype.h>

#include <char.h>
#include <input.h>
#include <chunkarr.h>
#include <ec.h>
#include <math.h>

@include <Objects/FlatFile/ffileC.goh>
@include <Objects/FlatFile/ffGrObjC.goh>
#include <Objects/FlatFile/ffDPaste.h>
@include <Objects/uiInputC.goh>
@include <Objects/Text/tCtrlC.goh>
#include <Objects/Text/tCommon.h>
@include <ffile.goh>
@include <grobj.goh>
#include <graphics.h>
#include <extern.h>
#include <Database/ffDExtrn.h>
#include <ffFatal.h>

/*************************************************************************
  	    	Class Declarations
 *************************************************************************/

@classdecl	FFTextFieldGuardianClass;


/*************************************************************************
  	    	External Declarations
 *************************************************************************/

@extern chunk @FFDConfirmDeleteField;

@extern chunk @FFDFieldHadDependents;

/*************************************************************************
  	    	Forward Declarations
 *************************************************************************/

/***********************************************************************
 *
 * MESSAGE:	MSG_META_INITIALIZE for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message resets the ward class for this guardian to
 *	    	FFTextClass.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/10/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_META_INITIALIZE
{
    @callsuper();

    pself = ObjDerefGrObj(oself);
    pself->GOVGI_class = (word *)&FFTextClass;

    /*
     * Turn off the flag that forces a resized field to have enough volume
     * to fit all of the text contained therein.
     */
    pself->TGI_flags &= (~TGF_ENFORCE_MIN_DISPLAY_SIZE &
			 ~TGF_ENFORCE_DESIRED_MIN_HEIGHT);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_GOVG_CREATE_VIS_WARD for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	Set the inDesignMode flag when a field is created.
 *
 * PARAMETERS:
 *	optr (MemHandle wardBlock)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	1/29/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_GOVG_CREATE_VIS_WARD
{
    optr wardOptr;

    wardOptr = @callsuper();

    /*
     * Tell our ward that it's in design mode
     */
    @send wardOptr::MSG_FFT_SIMPLE_SET_FOR_DESIGN_MODE();

    return(wardOptr);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_INITIALIZE for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This method sets the instance data for this guardian to point
 *	    	to the guardian of the associated label, and to set the edges
 *	    	to be on or off.
 *
 * PARAMETERS:
 *	void (VMBlockHandle vmBlockHandle,
 *	      ChunkHandle chunkHandle,
 *	      FieldEdgeFlags edgeFlags);
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/10/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_INITIALIZE
{
    pself->FFTFG_label.GOEOP_grObjectVMBlock = vmBlockHandle;
    pself->FFTFG_label.GOEOP_grObjectChunk = chunkHandle;

    /*
     * Sometimes you just want to leave them flags alone.
     */
    if (edgeFlags != FEF_LEAVE_EDGES_ALONE) {
	pself->FFTFG_edgeFlags = edgeFlags;
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_GET_LABEL_OPTR for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	
 *	This message sends back the optr of the label pointed to by
 *	FFTFG_label.
 *	Pass this message the document handle associated with this label.
 *
 * PARAMETERS:
 *	optr (VMFileHandle documentHandle)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/10/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_GET_LABEL_OPTR
{
    MemHandle grObjectMemBlock;

    /*
     * If we have no associated label, return a null handle.
     */
    if (!pself->FFTFG_label.GOEOP_grObjectVMBlock) {
	return (0);
    }

    /*
     * We have a label.  Return its optr.
     */
    grObjectMemBlock = VMVMBlockToMemBlock(documentHandle, 
				pself->FFTFG_label.GOEOP_grObjectVMBlock);
    return(ConstructOptr(grObjectMemBlock, 
				pself->FFTFG_label.GOEOP_grObjectChunk));
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_SET_FIELD_TYPE for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message sets the flat file field type for a
 *	    	particular field.
 *
 * PARAMETERS:
 *	void (FieldDataType fieldType)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/17/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_SET_FIELD_TYPE
{
    pself->FFTFG_fieldType = fieldType;

    ObjMarkDirty(oself);

    /*
     * Tell our ward its new type.
     */
    @send (pself->GOVGI_ward)::MSG_FFT_SET_FIELD_TYPE(fieldType, FALSE);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_SET_DISPLAY_FORMAT for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message sets the display format for a
 *	    	particular field.
 *
 * PARAMETERS:
 *	void (FormatIdType displayFormat)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	11/23/92	Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_SET_DISPLAY_FORMAT
{
    /*
     * Tell our ward its new display format.
     */
    @send (pself->GOVGI_ward)::MSG_FFT_SET_DISPLAY_FORMAT(displayFormat);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_SET_FOR_DATA_ENTRY for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message prepares a field for data entry.  If the
 *	    	field type is an editable one, it becomes editable.  Other-
 *	    	wise, it becomes non-editable (but still selectable).
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/17/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_SET_FOR_DATA_ENTRY
{
    optr ward = pself->GOVGI_ward;
    FieldDataType fieldType = pself->FFTFG_fieldType;
    
    switch (fieldType) {
	case FDT_COMPUTED:
	case FDT_PAGE_NUMBER:
	case FDT_GENERAL_TEXT:
	case FDT_INTEGER:
	case FDT_REAL:
	case FDT_DATE:
	case FDT_TIME:
	    (void) @call self::MSG_GO_CHANGE_LOCKS(
                (GOL_LOCK | GOL_MOVE | GOL_RESIZE | GOL_ROTATE | GOL_SKEW |
	         GOL_DELETE | GOL_ATTRIBUTE | GOL_GROUP |
		 GOL_SELECT), (GOL_LOCK | GOL_DRAW | GOL_PRINT | GOL_EDIT));
	    break;
    }

    /*
     * Tell our ward to listen to target losses.
     */
    @send ward::MSG_FFT_SET_FOR_DATA_ENTRY_MODE();
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_SIMPLE_SET_FOR_DESIGN_MODE 
 *		for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message just sets the inDesignMode flag for the fields
 *		and nothing else!
 *
 *		This is necessary because we have a case (in FFDSwitchToLayout)
 *		where we could be in design mode, moving from multi-record
 *		to single-record. Let's also assume that the single-record
 *		objects are set for data entry mode.
 *		If we try to attach the single-record layout first and
 *		then set its grobjects correctly, then it sends 
 *		LOST_TARGET_EXCLS to the field, which thinks it is in data
 *		entry mode and therefore processes it (it should just ignore
 *		it).
 *		If we try to switch the grobjects to being in design mode
 *		first, we have the following problem: To be in design mode,
 *		the fields have to display their field names. They request
 *		their field names by vupping up. But if the current layout
 *		is not attached yet, then the fields aren't in the visual
 *		tree, and their request for a field name goes nowhere.
 *
 *		So this routine is meant to deal with this problem: before
 *		the single-record layout is attached, this message will
 *		be sent. Then, when the layout is attached, the fields
 *		will not respond to the LOST_TARGET_EXCL messages.
 *
 *		Other use of this message is not recommended.
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	1/25/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_SIMPLE_SET_FOR_DESIGN_MODE
{
    optr ward = pself->GOVGI_ward;

    /*
     * Tell our ward that it is in design mode
     */
    @send ward::MSG_FFT_SIMPLE_SET_FOR_DESIGN_MODE();
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_SET_FOR_DESIGN_MODE for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message prepares a field for design mode by
 *	    	setting it not editable and requesting the database
 *	    	to set its name.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/17/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_SET_FOR_DESIGN_MODE
{
    optr ward = pself->GOVGI_ward;

    /*
     * Set ourself to be not editable.
     */
    @call self::MSG_GO_CHANGE_LOCKS(GOL_LOCK | GOL_EDIT, GOL_LOCK);

    /*
     * Tell our ward to request its own name, to ignore target losses,
     * and to not redraw the field name if we're printing in design mode.
     */
    @send ward::MSG_FFT_SET_FOR_DESIGN_MODE();
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_RELEASE_LABEL for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message is sent by a field's label when the label
 *	    	is being nuked.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/29/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_RELEASE_LABEL
{
    pself->FFTFG_label.GOEOP_grObjectVMBlock = NullHandle;
    pself->FFTFG_label.GOEOP_grObjectChunk = NullHandle;

    ObjMarkDirty(oself);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_SET_EDGES for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message sets which of a field's four border
 *	    	lines will be drawn.  Pass it FieldEdgeFlags to indicate
 *	    	which lines to draw, and send a redraw flag if you want
 *	    	it to be immeadiately redrawn.
 *
 * PARAMETERS:
 *	void (FieldEdgeFlags edges, Boolean redraw);
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	9/21/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_SET_EDGES
{
    pself->FFTFG_edgeFlags = edges;

    ObjMarkDirty(oself);

    if (redraw) {
	@call oself::MSG_GO_INVALIDATE();
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_GO_DRAW_FG_LINE for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	We intercept this message to selectively draw lines
 *	    	around text objects.
 *
 * PARAMETERS:
 *	void (DrawFlags drawFlags = cl,
 *	      GrObjDrawFlags grobjDrawFlags= ch,
 *	      GStateHandle gstate = dx)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	9/21/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_GO_DRAW_FG_LINE,
    	    	    	    	  MSG_GO_DRAW_FG_LINE_HI_RES
{
    WWFixed width, height;
    sword x1, y1, x2, y2;
    Point polyLine[2 + 1 + 1];  	/* <- the max points in the biggest
					      polyline (3 edges). */
    int polyCount;
    FieldEdgeFlags eFlags = pself->FFTFG_edgeFlags;
    
    /*
     * If no edges are to be drawn, leave.
     */
    if (!eFlags) {
	return;
    }

    /*
     * At least one edge needs to be redrawn.  Calculate the endpoints.
     */
    GrObjGetNormalOBJECTDimensions(oself, &width, &height);
    GrObjCalcCorners(width, height, &x1, &y1, &x2, &y2, gstate);

    /*
     * If all edges are used, draw a rectangle and leave.
     */
    if (eFlags == FEF_ALL_EDGES) {
	GrDrawRect(gstate, x1, y1, x2, y2);
	return;
    }

    /*
     * Initialize a counter in case we need to draw a polyline.
     */
    polyCount = 0;

    /*
     * Individual edges are toggled.
     *
     * Due to the fact that thick lines do not join square with the
     * above coordinates, we have to draw a polyline if any edges
     * meet.  Otherwise, we can simply draw the line(s) individually.
     */
    switch (eFlags) {
	/*
	 * Here are the simple individual line drawing cases.
	 */
	case FEF_TOP:
	case FEF_LEFT:
	case FEF_RIGHT:
	case FEF_BOTTOM:
	case (FEF_LEFT | FEF_RIGHT):
	case (FEF_TOP | FEF_BOTTOM):
	    if (eFlags & FEF_LEFT) {
		GrDrawLine(gstate, x1, y1, x1, y2);
	    }
	    if (eFlags & FEF_TOP) {
		GrDrawLine(gstate, x1, y1, x2, y1);
	    }
	    if (eFlags & FEF_BOTTOM) {
		GrDrawLine(gstate, x1, y2, x2, y2);
	    }
	    if (eFlags & FEF_RIGHT) {
		GrDrawLine(gstate, x2, y1, x2, y2);
	    }
	    /*
	     * We're done.
	     */
	    return;
	
	/*
	 * Deal with the polyline cases.
	 */
	case (FEF_LEFT | FEF_TOP):
	case (FEF_LEFT | FEF_TOP | FEF_RIGHT):
	    if (eFlags & FEF_LEFT) {
		polyLine[polyCount].P_x   = x1;
		polyLine[polyCount++].P_y = y2;
		polyLine[polyCount].P_x   = x1;
		polyLine[polyCount++].P_y = y1;
	    }
	    if (eFlags & FEF_TOP) {
		polyLine[polyCount].P_x   = x2;
		polyLine[polyCount++].P_y = y1;
	    }
	    if (eFlags & FEF_RIGHT) {
		polyLine[polyCount].P_x   = x2;
		polyLine[polyCount++].P_y = y2;
	    }
	    break;

	case (FEF_TOP  | FEF_RIGHT):
	case (FEF_TOP  | FEF_RIGHT | FEF_BOTTOM):
	    if (eFlags & FEF_TOP) {
		polyLine[polyCount].P_x   = x1;
		polyLine[polyCount++].P_y = y1;
		polyLine[polyCount].P_x   = x2;
		polyLine[polyCount++].P_y = y1;
	    }
	    if (eFlags & FEF_RIGHT) {
		polyLine[polyCount].P_x   = x2;
		polyLine[polyCount++].P_y = y2;
	    }
	    if (eFlags & FEF_BOTTOM) {
		polyLine[polyCount].P_x   = x1;
		polyLine[polyCount++].P_y = y2;
	    }
	    break;

	case (FEF_RIGHT | FEF_BOTTOM):
	case (FEF_RIGHT | FEF_BOTTOM | FEF_LEFT):
	    if (eFlags & FEF_RIGHT) {
		polyLine[polyCount].P_x   = x2;
		polyLine[polyCount++].P_y = y1;
		polyLine[polyCount].P_x   = x2;
		polyLine[polyCount++].P_y = y2;
	    }
	    if (eFlags & FEF_BOTTOM) {
		polyLine[polyCount].P_x   = x1;
		polyLine[polyCount++].P_y = y2;
	    }
	    if (eFlags & FEF_LEFT) {
		polyLine[polyCount].P_x   = x1;
		polyLine[polyCount++].P_y = y1;
	    }
	    break;

	case (FEF_BOTTOM | FEF_LEFT):
	case (FEF_BOTTOM | FEF_LEFT | FEF_TOP):
	    if (eFlags & FEF_BOTTOM) {
		polyLine[polyCount].P_x   = x2;
		polyLine[polyCount++].P_y = y2;
		polyLine[polyCount].P_x   = x1;
		polyLine[polyCount++].P_y = y2;
	    }
	    if (eFlags & FEF_LEFT) {
		polyLine[polyCount].P_x   = x1;
		polyLine[polyCount++].P_y = y1;
	    }
	    if (eFlags & FEF_TOP) {
		polyLine[polyCount].P_x   = x2;
		polyLine[polyCount++].P_y = y1;
	    }
	    break;
    }

    #ifdef ERROR_CHECK
    	if (polyCount > 4) {
	    EC_ERROR(TOO_MANY_POINTS_IN_THE_FIELD_EDGES);
	}
    #endif

    GrDrawPolyline(gstate, polyLine, polyCount);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_GO_CLEAR for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message is intercepted so we can tell our ward to
 *	    	notify itself that we're no longer alive.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	6/29/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_GO_CLEAR
{
    MemHandle grObjectMemBlock;
    word grObjVMBlock, grObjChunk;
    VMFileHandle documentHandle;
    optr labelOptr;
    UIInterfaceLevel userLevel;
    TCHAR fieldName[MAX_FIELD_NAME_LENGTH + 1];
    Boolean nukeFlag; 
    optr ward = pself->GOVGI_ward;

    /*
     * Set a flag if we're to delete this field without asking the
     * user for permission or notifying the database.
     */
    nukeFlag = (ObjVarFindData(oself, FFTFG_NUKE_FLAG)) ? TRUE : FALSE;
    
    /*
     * If we're in user level 2, we have to ask whether or not to go away.
     */
    userLevel = GET_UI_INTERFACE_LEVEL (@call GeodeGetAppObject(0)::
	MSG_GEN_APPLICATION_GET_APP_FEATURES());
    
    if (!nukeFlag && (userLevel == UIIL_BEGINNING)) {
	@call ward::MSG_FFT_GET_FIELD_NAME(fieldName);
	
	/*
	 * If the field has dependents, it cannot be deleted.
	 */
	if (@call ward::MSG_FFT_FIELD_HAS_DEPENDENCIES()) {
	    MemLock(OptrToHandle(@FFDFieldHadDependents));

	    UserStandardDialog(
	    	(TCHAR *)0,
                /* not GIT_MULTIPLE_RESPONSE, so no custom triggers  */
                (TCHAR *)0,
                /* One string argument: the field name. */
                (TCHAR *)0, fieldName,
                /* dialog string */
		LMemDeref(@FFDFieldHadDependents),
                /* dialog type */
                (CDT_WARNING << CDBF_DIALOG_TYPE_OFFSET) |
                /* interaction type */
                (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));

	    /* Release the warning string */
	    MemUnlock(OptrToHandle(@FFDFieldHadDependents));
	    return;
	}
	    
	/*
	 * We need to ask permission before nuking this field.
	 */
        MemLock (OptrToHandle(@FFDConfirmDeleteField));
	if (UserStandardDialog(
	    	(TCHAR *)0,
                /* not GIT_MULTIPLE_RESPONSE, so no custom triggers  */
                (TCHAR *)0,
                /* One string argument: the field name. */
                (TCHAR *)0, fieldName,
                /* dialog string */
		LMemDeref(@FFDConfirmDeleteField),
                /* dialog type */
                (CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET) |
                /* interaction type */
                (GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET)) == IC_NO) {
	    MemUnlock (OptrToHandle (@FFDConfirmDeleteField));
	    return;
	}

	/*
	 * The user really wants to delete the thing.  Ok, they asked for it.
	 */
 	MemUnlock (OptrToHandle (@FFDConfirmDeleteField));
    }

    #if ERROR_CHECK
    	if (userLevel == UIIL_INTRODUCTORY) {
	    EC_ERROR(INAPPROPRIATE_USER_LEVEL);
	}
    #endif

    /*
     * If we have a label attached to us, tell it we're going away.
     */
    pself = ObjDerefGrObj(oself);
    if (pself->FFTFG_label.GOEOP_grObjectVMBlock != NullHandle) {
	grObjVMBlock = pself->FFTFG_label.GOEOP_grObjectVMBlock;
	grObjChunk = pself->FFTFG_label.GOEOP_grObjectChunk;

	/*
	 * We have an associated field.  We need our document handle to
	 * tell the field we're going away.
	 */
	documentHandle = @call ward::MSG_FFT_GET_DOCUMENT_HANDLE();

	grObjectMemBlock = VMVMBlockToMemBlock(documentHandle, grObjVMBlock);
       	labelOptr = ConstructOptr(grObjectMemBlock, grObjChunk);

	/*
	 * We need to be sure that this is a deletable object first.
	 */
	@call labelOptr::MSG_GO_CHANGE_LOCKS(0, GOL_LOCK | GOL_DELETE);

	/*
	 * We have our label optr.  Tell it goodbye.
	 */
    	@send labelOptr::MSG_FFLG_RELEASE_FIELD();
    }

    /*
     * Tell our ward to tell the flat file that we're being deleted.
     */
    if (!nukeFlag) {
	@call ward::MSG_FFT_REPORT_DEMISE(userLevel == UIIL_BEGINNING);
    }

    /*
     * We need to be sure that this is a deletable object first.
     */
    @call oself::MSG_GO_CHANGE_LOCKS(0, GOL_LOCK | GOL_DELETE);

    @callsuper();
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_NUKE_FIELD for FFTextFieldGuardianClass
 *
 * DESCRIPTION: This message is sent when the current field is to be
 *	    	deleted with no user- or database verification.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	12/10/92	Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_NUKE_FIELD
{
    Boolean *nukeFlag;
    
    /*
     * Set some vardata to signal that we're supposed to be deleted
     * with no user- or database verification.
     */
    nukeFlag = (Boolean *)ObjVarAddData(oself,
					FFTFG_NUKE_FLAG,
					sizeof(Boolean));

    *nukeFlag = TRUE;

    /*
     * Now delete ourself.
     */
    @send oself::MSG_GO_CLEAR();
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_PING for FFTextFieldGuardianClass
 *
 * DESCRIPTION: This message simply increments a passed flag.  Used to
 *	    	detect if at least one FFTFG exists in a grobj body.
 *
 * PARAMETERS:
 *	void (word *incrementMe)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	9/23/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_PING
{
    (*incrementMe)++;
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTG_PASTE_ALERT for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message is sent by the database to fields that 
 *	    	have just been pasted into the layout.  Individual
 *	    	fields need to tell the database about their existence
 *	    	so that new fields can be created for them (or old
 *	    	ones inserted into the current layout).
 *
 *	    	The address to an array of labels is passed as well,
 *	    	for field GrObjects to look through and see if there
 *	    	is a matching label that is to be re-attached to
 *	    	its field.  If a matching label is found, it is removed
 *	    	from the array to speed up later searches.
 *
 * PARAMETERS:
 *	void (LabelIDArray *labels)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	8/13/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_PASTE_ALERT
{
    int i, numLabels;
    VMBlockHandle expectedVMB;
    ChunkHandle expectedCH;
    optr ourLabel;
    optr ward = pself->GOVGI_ward;

    /*
     * First, scan through the labels to see if ours exists.
     */
    ourLabel = NullOptr;
    expectedVMB = pself->FFTFG_label.GOEOP_grObjectVMBlock;
    expectedCH = pself->FFTFG_label.GOEOP_grObjectChunk;
    
    if (expectedVMB != NullHandle || expectedCH != NullHandle) {
	numLabels = labels->numLabels;
	for (i = 0; i < numLabels; i++) {
	    if (labels->labelSet[i].VMBlock == expectedVMB &&
		labels->labelSet[i].chunk == expectedCH) {
		/* Found it! */
		ourLabel = labels->labelSet[i].labelOptr;
		break;
	    }
	}

	/*
	 * If we found one, remove its reference from the array.
	 */
	for ( /* nothing */ ; i < numLabels; i++) {
	    labels->labelSet[i].VMBlock = labels->labelSet[i+1].VMBlock;
	    labels->labelSet[i].chunk = labels->labelSet[i+1].chunk;
	    labels->labelSet[i].labelOptr = labels->labelSet[i+1].labelOptr;
	}

	if (ourLabel) {
	    labels->numLabels--;
	}
    }

    /*
     * In case we don't get added, or our label didn't get pasted,
     * clear out our old label's VMBlock and Chunk.
     */
    pself->FFTFG_label.GOEOP_grObjectVMBlock = NullHandle;
    pself->FFTFG_label.GOEOP_grObjectChunk = NullHandle;
    
    /*
     * Now tell the database of our existence.
     */
    @send ward::MSG_FFT_REPORT_PASTED_FIELD(labels->databaseOptr,
					    oself,
					    ourLabel);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_UPDATE_PAGE_NUMBER for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message is sent when all page number fields should
 *	    	update themselves with a new page number.
 *
 * PARAMETERS:
 *	void ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	9/17/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_UPDATE_PAGE_NUMBER
{
    if (pself->FFTFG_fieldType == FDT_PAGE_NUMBER) {
	FFTRequestPageNumber(pself->GOVGI_ward);
    }
}

/***********************************************************************
 *
 * MESSAGE:	MSG_GO_WRITE_INSTANCE_TO_TRANSFER for
 *	    	    	    	    	    	FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message is sent out when a field is copied or cut
 *	    	to the clipboard.  This is where we save off our own
 *	    	and our ward's instance data to the passed VMFile block.
 *
 * PARAMETERS:
 *	void (GrObjTransferParams *params)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	9/24/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_GO_WRITE_INSTANCE_TO_TRANSFER
{
    MemHandle transferBlockHandle;
    FFTextGuardianAndWardInstanceDataStruct *transferBlock;
    char *p;	    	    /* do not make TCHAR */
    optr ward = pself->GOVGI_ward;

#if ERROR_CHECK

    /*
     * Make sure that the size of our transfer block is the same size
     * as the instance data we should be saving.
     */
    if (sizeof(FFTextGuardianAndWardInstanceDataStruct) !=
	((sizeof(FFTextFieldGuardianInstance) - sizeof(TextGuardianInstance)) +
	 (sizeof(FFTextInstance) - sizeof(GrObjTextInstance)) +
	 (sizeof(VisTextCharAttr)) + sizeof(VisTextParaAttr))) {
	EC_ERROR(BAD_TRANSFER_BLOCK_SIZE_FIX_THE_NEW_INSTANCE_DATA_BOZO);
    }

#endif /* ERROR_CHECK */

    /*
     * Call superclass, updating params->GTP_curPos.
     */
    @callsuper();

    /*
     * Add the size of our instance data to the saved structure, and to
     * save time, the size of our ward's as well.
     */
    params->GTP_curSize += sizeof(FFTextGuardianAndWardInstanceDataStruct);

    /*
     * Lock down the VM block so we can add to it.
     */
    p = VMLock(params->GTP_vmFile,
	       SegmentOf(params->GTP_id),
	       &transferBlockHandle);

    /*
     * Allocate more space for our instance and our ward's instance
     * data, and get deref pointers for the big transfer.
     */
    (void) MemReAlloc(transferBlockHandle, params->GTP_curSize, HAF_NO_ERR);

    pself = ObjDerefGrObj(oself);
    p = MemDeref(transferBlockHandle);

    /*
     * Copy our instance data to the new area of the resized block.
     */
    transferBlock =
	(FFTextGuardianAndWardInstanceDataStruct *)(p + params->GTP_curPos);
    transferBlock->g_indata.FFTFG_fieldType = pself->FFTFG_fieldType;
    transferBlock->g_indata.FFTFG_label = pself->FFTFG_label;
    transferBlock->g_indata.FFTFG_edgeFlags = pself->FFTFG_edgeFlags;

    /*
     * Now tell our ward to copy its special instance data to the
     * structure.
     */
    @call ward::MSG_FFT_WRITE_INSTANCE_TO_TRANSFER(&transferBlock->t_indata);

    /*
     * All done!  Unlock the block.
     */
    VMUnlock(transferBlockHandle);

    /*
     * Indicate that we wrote the class, then leave.
     */
    params->GTP_curPos += sizeof(FFTextGuardianAndWardInstanceDataStruct);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_GO_READ_INSTANCE_FROM_TRANSFER for
 *	    	    	    	    	    	FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message is sent out when a field is pasted from
 *	    	the clipboard.  This is where we reset off our own
 *	    	and our ward's instance data from the passed VMFile block.
 *
 * PARAMETERS:
 *	void (GrObjTransferParams *params)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	9/24/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_GO_READ_INSTANCE_FROM_TRANSFER
{
    MemHandle transferBlockHandle;
    FFTextGuardianAndWardInstanceDataStruct *transferBlock;
    char *p;	    /* do not make TCHAR */
    FFTInstanceData *wardData;

#if ERROR_CHECK

    /*
     * Make sure that the size of our transfer block is the same size
     * as the instance data we should be saving.
     */
    if (sizeof(FFTextGuardianAndWardInstanceDataStruct) !=
	((sizeof(FFTextFieldGuardianInstance) - sizeof(TextGuardianInstance)) +
	 (sizeof(FFTextInstance) - sizeof(GrObjTextInstance)) +
	 (sizeof(VisTextCharAttr)) + sizeof(VisTextParaAttr))) {
	EC_ERROR(BAD_TRANSFER_BLOCK_SIZE_FIX_THE_NEW_INSTANCE_DATA_BOZO);
    }

#endif /* ERROR_CHECK */

    /*
     * Call superclass, updating params->GTP_curPos.
     */
    @callsuper();

    /*
     * Lock down the VM block so we can read from it.
     */
    p = VMLock(params->GTP_vmFile,
	       SegmentOf(params->GTP_id),
	       &transferBlockHandle);

    /*
     * Deref ourself.
     */
    pself = ObjDerefGrObj(oself);

    /*
     * Read our instance data from the block.
     */
    transferBlock = 
	(FFTextGuardianAndWardInstanceDataStruct *)(p + params->GTP_curPos);
    pself->FFTFG_fieldType = transferBlock->g_indata.FFTFG_fieldType; 
    pself->FFTFG_label = transferBlock->g_indata.FFTFG_label; 
    pself->FFTFG_edgeFlags = transferBlock->g_indata.FFTFG_edgeFlags;

    /*
     * Now copy our ward's data from the transfer block to  our own vardata,
     * because the ward doesn't exist at this point.
     */
    wardData = (FFTInstanceData *)ObjVarAddData(oself,
			     FFTFG_TEMPORARY_WARD_INSTANCE_DATA,
			     sizeof(FFTInstanceData));
    memcpy(wardData, &(transferBlock->t_indata), sizeof(FFTInstanceData));

    /*
     * All done!  Unlock the block.
     */
    VMUnlock(transferBlockHandle);

    /*
     * Indicate that we read the class, then leave.
     */
    params->GTP_curPos += sizeof(FFTextGuardianAndWardInstanceDataStruct);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_GO_REPLACE_WITH_TRANSFER for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	We intercept this to load our ward with instance data
 *	    	we saved off into our own vardata in READ_INSTANCE_FROM_
 *	    	TRANSFER.
 *
 * PARAMETERS:
 *	void (GrObjTransferParams *params)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	10/16/92	Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_GO_REPLACE_WITH_TRANSFER
{
    FFTInstanceData *wardData;

    /*
     * Read the transfer, create the vardata, and create our ward.
     */
    @callsuper();
    
    /*
     * Grab the vardata that holds our ward's instance data.
     */
    wardData = ObjVarFindData(oself, FFTFG_TEMPORARY_WARD_INSTANCE_DATA);

    /*
     * Tell our ward to load its instance data with this stuff.
     */
    pself = ObjDerefGrObj(oself);
    @call pself->GOVGI_ward::MSG_FFT_READ_INSTANCE_FROM_TRANSFER(wardData);

    /*
     * Done.  Nuke the vardata.
     */
    ObjVarDeleteData(oself, FFTFG_TEMPORARY_WARD_INSTANCE_DATA);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_GO_GAINED_SELECTION_LIST for FFFieldTextGuardianClass
 *
 * DESCRIPTION:	Tell our body that we became selected so that our appearence
 *	    	flags can be sent out to UI controllers who need to know.
 *
 * PARAMETERS:
 *	void (HandleUpdateMode hum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	10/ 6/92	Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_GO_GAINED_SELECTION_LIST
{
    /*
     * Call our superclass first to get that out of the way.
     */
    @callsuper();

    /*
     * Now tell the body that we just became selected.
     */
    pself = ObjDerefGrObj(oself);
    GrObjMessageToBody(SegmentOf(pself),
		       MSG_FFGB_SET_FIELD_APPEARENCES_FLAG,
		       0, 0, 0);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_GO_LOST_SELECTION_LIST for FFFieldTextGuardianClass
 *
 * DESCRIPTION:	Tell our body that we are no longer selected so that any
 *	    	remaining fields can have their appearence flags sent out
 *	    	to UI controllers who need to know.
 *
 * PARAMETERS:
 *	void (HandleUpdateMode hum)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	10/ 6/92	Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_GO_LOST_SELECTION_LIST
{
    /*
     * Call our superclass first to get that out of the way.
     */
    @callsuper();

    /*
     * Now tell the body that we just lost selection.
     */
    pself = ObjDerefGrObj(oself);
    GrObjMessageToBody(SegmentOf(pself),
		       MSG_FFGB_SET_FIELD_APPEARENCES_FLAG,
		       0, 0, 0);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_UPDATE_UI_BLOCK for FFTextFieldGuardianClass
 *
 * DESCRIPTION:	This message is called when one or more fields become
 *	    	selected, and the various field appearence controllers
 *	    	need to be updated.
 *
 *	        What we'll do here is take the passed data block and
 *	    	describe our appearence via edge flags and format
 *	    	tokens.  If there are different edge flags set, we'll
 *	    	set the corresponding "indeterminate" flags.
 *
 * PARAMETERS:
 *	void (MemHandle appearenceChangeBlock)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	10/ 6/92		Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_UPDATE_UI_BLOCK
{
    FFFieldAppearanceChangeMessageBlock *appearenceChange;
    word selected, indeterminate;
    FormatIdType formatIdType;

    appearenceChange = MemLock(appearenceChangeBlock);
    formatIdType = @call pself->GOVGI_ward::MSG_FFT_RETURN_FORMAT_TYPE();

    /*
     * If we're the very first field to get this message,
     * Load up the selected list to be our edges, and
     * clear the indeterminate flags.
     */
    pself = ObjDerefGrObj(oself);
    if (appearenceChange->FFESCM_setEdges & FEF_FIRST_FIELD_FLAG) {

	/*
	 * Note that the FFTFG_edgeFlags can never have the
	 * FEF_FIRST_FIELD_FLAG bit set, so the next line clears
	 * that flag.
	 */
	appearenceChange->FFESCM_setEdges = pself->FFTFG_edgeFlags;
	appearenceChange->FFESCM_indeterminateEdges = 0;
	appearenceChange->FFESCM_formatIdType = formatIdType;

	#ifdef ERROR_CHECK
	if (!formatIdType) {
	    EC_ERROR(BAD_DISPLAY_FORMAT);
	}
	#endif
    } else { 

	/*
	 * Compare our edge flags with those in the block.
	 * If they differ, figure out which flags are the same, and
	 * which are different.  The  flags that are different are
	 * considered to be indeterminate.
	 */
	selected = pself->FFTFG_edgeFlags & appearenceChange->FFESCM_setEdges;
	
	indeterminate =
	    (pself->FFTFG_edgeFlags | appearenceChange->FFESCM_setEdges) &
		~selected;

	appearenceChange->FFESCM_setEdges = selected;
	appearenceChange->FFESCM_indeterminateEdges |= indeterminate;

	/*
	 * Is our format the same as our predecessors'?  If not, set it
	 * indeterminate.  Otherwise, leave it.
	 */
	if (appearenceChange->FFESCM_formatIdType != formatIdType) {
	    appearenceChange->FFESCM_formatIdType = FORMAT_ID_INDETERMINATE;
	}
    }

    MemUnlock(appearenceChangeBlock);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_RESET_DEFINED_TYPE for FFTextFieldGuardianClass
 *
 * DESCRIPTION: This message is passed immediately on to our ward, which checks
 *	    	to see if the passed format id type matches its current id type.
 *	    	If there's a match, the current type is replaced with the
 *	    	newFormat.
 *
 *
 * PARAMETERS:
 *	void (FormatIdType formatToReset, FormatIdType newFormat)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	12/ 2/92	Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_RESET_DEFINED_TYPE
{
    @call pself->GOVGI_ward::MSG_FFT_RESET_DEFINED_TYPE(formatToReset,
							newFormat);
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFTFG_GET_DISPLAY_ARRAY_ELEMENT for
 *	    	FFTextFieldGuardianClass
 *
 * DESCRIPTION: Store display format into display array.
 *
 * PARAMETERS:
 *	void (Segment getDisplayArrayInfoSegment,
 *	    	    word getDisplayArrayInfoOffset)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	brianc	11/28/94	Initial version
 *
 ***********************************************************************/
@method FFTextFieldGuardianClass, MSG_FFTFG_GET_DISPLAY_ARRAY_ELEMENT
{
    @call pself->GOVGI_ward::MSG_FFT_GET_DISPLAY_ARRAY_ELEMENT(
       ((GetDisplayArrayInfo *)(((dword)getDisplayArrayInfoSegment<<16) |
			    	    	    	getDisplayArrayInfoOffset)));
}


