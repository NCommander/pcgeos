/***********************************************************************
 *
 *	Copyright (c) Geoworks 1992 -- All Rights Reserved
 *
 * PROJECT:	  PCGEOS
 * MODULE:	  ffDatabaseRCP.goc
 * FILE:	  ffDatabaseRCP.goc
 *
 * AUTHOR:  	  Jeremy Dashe : Dec 22, 1992
 *
 * DESCRIPTION:
 *	This file contains support code for dealing with the Record Control
 *	Panel's messages in the flat file database library.
 *
 * RCS STAMP:
 *	$Id: ffDatabaseRCP.goc,v 1.1 97/04/04 18:02:59 newdeal Exp $
 *
 ***********************************************************************/

@include <stdapp.goh>
#include <geoworks.h>
#include <system.h>

#include <Ansi/string.h>
#include <Ansi/stdio.h>

#include <ec.h>
@include <Objects/FlatFile/ffileC.goh>
@include <Objects/FlatFile/ffDbase.goh>
@include <Objects/vTextC.goh>
#include <char.h>
@include <ffile.goh>
@include <grobj.goh>
#include <extern.h>
#include <ffFatal.h>
@include <Objects/FlatFile/ffRecC.goh>

#include <Database/ffDExtrn.h>

@extern chunk @FFConfirmDeleteRecordString;

#define FFD_CURRENT_RECORD(x)   (x->FFI_showOnlyMarked ? \
				 x->FFI_currentMarkedRecord : \
				 x->SSI_active.CR_row)

/*************************************************************************
 	Forward Declarations
 *************************************************************************/

Boolean FFDRCCreateNewRecordForMultiRecDataEntry(optr oself);

void FFDScrollToCurrentRecord(optr oself);

void FFDUpdatePageNumbers(optr oself);

void FFDDeleteRecordOnMultiRecordLayout (optr oself);

void FFDCalculateBoundsForActiveRecord(optr oself, 
				       optr grObjBody,
				       word newRecord,
				       word numHorizontalRecords,
				       word numVerticalRecords,
				       RectDWord *recordLayoutBounds);

void FFDCalculateBoundsForActiveRecordAndSetGrObjBody(optr oself, 
						 optr grObjBody,
						 word newRecord,
						 word numHorizontalRecords,
						 word numVerticalRecords);

void FFDRCMoveGrObjBodyForMultiRecDataEntry(optr oself, word newRecord,
						Boolean *stayOnThisPage);

word FFDRCGetNewRecord(optr oself, FFRecordControlRequest rcpRequest,
				word newRecord);

word FFDRCGetNewMarkedRecord(optr oself,
			     FFRecordControlRequest rcpRequest,
			     word newRecord);

Boolean FFDRCGotoRecord(optr oself,
		 FFRecordControlRequest rcpRequest,
		 word newRecord,
		 Boolean moveGrObjBody,
		 CommitRecordType commitRecordType,
		 EditRecordType editRecordType,
		 Boolean fieldGrabTarget);

void _pascal FFDSendRCPNotification
			(optr oself,
			 FFRecordControlStatusMessageBlock *ffrcpsmb);

static _pascal Boolean FFDRCDeleteRecord
			(optr oself,
			 FFRecordControlRequest rcpRequest);

void FFDRCAutoMark(optr oself, word recordNum);

Boolean
FFDRCRecordMovement(optr oself,
		 FFRecordControlRequest rcpRequest,
		 word newRecord);


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		MSG_FFD_RECORD_CONTROL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DESCRIPTION:	Perform the given record control command and make all of
		the necessary GCN notifications.

PASS: 		FFRecordControlRequest	rcpRequest	= Record control
							  command function.
		word	data	= Usage varies by requested function.

RETURN:		Boolean	= TRUE iff the requested operation was successful.
			  FALSE otherwise.

PSEUDO CODE/STRATEGY:
	Figure out what to do:
		Create New Record:
			Commit the current record being edited (if any).
			Edit a new record.
		Commit Current Record:
			Commit the current record being edited (if any) and
			keep it as the current record.
		Revert Current Record:
			Revert the display of the currently being edited
			(if any).
		Delete Current Record:
			Delete the current record from the database.
		Goto Record XX:
			Make the specified record the current record in the
			database.
		Mark Current Record:
		    	Sets the "marked" flag for the current record and
			sets the dirty record flag.
		Unmark Current Record:
		    	Clears the "marked" flag for the current record and
			sets the dirty record flag.
		Dirty Current Record:
			Set the dirty record flag.
		Clean Current Record:
			Clear the dirtry record flag.
		Refresh:
			Refresh the state of the Record Control Panel based
			on the current state of the appropriate database
			instance data.  This is provided for cases such as
			Import where changes have been made to the database
			behind the back of the RCP.
	Notify the Record Control Panel UI controller of the changes.

REQUIRES:	self^.FFI_editingNewRecord,
		self^.FFI_dirtyRecord,
		self^.FFI_totalNumRecordsInDatabase, and
		self^.SSI_active.CR_row are all set appropriately.

ASSERTS:	???

CHECKS:		Validates the given FFRecordControlRequest, the total
		number of records in the database, and the current record
		index.

KNOWN DEFECTS/SIDE EFFECTS/CAVEATS/IDEAS:
	Note that all indices (record numbers, etc.) are zero based.

	Something to think about is what the right thing to do is on some
	of the boundary conditions with respect to the RCP notification
	(e.g. the case where there are no records in the database and the
	caller wants to delete a record).

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	JDM	92.07.16	Initial version.
	JDM	92.08.20	Updated for new status flags.
	JDM	92.09.10	Added Refresh support and more EC code.
	AML	92.09.11	Added some specific stuff for multi-record,
				data entry case.
	jdashe	09/30/92    	Added page number updating.
	JDM	93.01.15	Modified REFRESH to forcefully update the
				entire screen iff in multi-record layout
				mode.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
@extern method FlatFileDatabaseClass, MSG_FFD_RECORD_CONTROL
{
    FFRecordControlStatusMessageBlock	ffrcpsmb;
    Boolean	editNewRecordP;
    Boolean	successP;
    word    	curRecord;
    word    	startingPage, numRecordsPerPage;
    EventHandle	event;
    optr 	recordLayoutGrObjBody;

#if ERROR_CHECK

    /* Validate the request.	*/
    if ((FFRCR_NULL_REQUEST >= rcpRequest) ||
	(FFRCR_INVALID_REQUEST <= rcpRequest))
	{
	EC_ERROR (INVALID_RECORD_CONTROL_REQUEST);
	}

    /* Validate the number of records.	*/
    if (MAX_NUM_RECORDS < pself->FFI_totalNumRecordsInDatabase)
	{
	EC_ERROR (INVALID_NUM_RECORDS);
	}

    /* Validate the current record index.	*/
    if (pself->FFI_totalNumRecordsInDatabase &&
	(pself->SSI_active.CR_row > pself->FFI_totalNumRecordsInDatabase) &&
	(pself->FFI_editingNewRecord == FALSE))
	{
	EC_ERROR (INVALID_CURRENT_RECORD_INDEX);
	}

#endif

    successP = FALSE;		/* Assume requested operation fails.	*/
    editNewRecordP = FALSE;	/* Assume normal data record. 	    	*/

    /*
     * Remember the page we were on before moving.
     */
    startingPage = pself->FFI_currentPage;

    /*
     * If we're in multi-record and moving to another record, we want the
     * current text object to lose the focus. We can ensure this by having
     * the record layout grobj body lose the target
     */
    if (pself->FFI_currentLayoutType == LT_MULTI_RECORD) {
	switch (rcpRequest) {
	    case FFRCR_CREATE_NEW_RECORD:
	    case FFRCR_GOTO_FIRST_RECORD:
	    case FFRCR_GOTO_PREVIOUS_RECORD:
	    case FFRCR_GOTO_NEXT_RECORD:
	    case FFRCR_GOTO_LAST_RECORD:
	    case FFRCR_GOTO_RECORD:
		recordLayoutGrObjBody = @call oself::
			MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT(
					pself->FFI_currentLayout, 
					LT_SINGLE_RECORD);
		@call recordLayoutGrObjBody::MSG_META_RELEASE_TARGET_EXCL();
		@call recordLayoutGrObjBody::MSG_META_RELEASE_FOCUS_EXCL();
		break;
	}
    }

    /* Figure out what the caller wants.	*/
    pself = ObjDerefGen(oself);
    switch (rcpRequest)
	{
	case FFRCR_REFRESH:
	    /*
	     * Force a complete screen redraw iff in multi-record layout
	     * mode.
	     */
	    if (LT_MULTI_RECORD == pself->FFI_currentLayoutType)
		{
                event = @record GenViewClass::MSG_GEN_VIEW_REDRAW_CONTENT();
                @send oself::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS (event);
		successP = TRUE;
		}
 	    else {
		if (pself->FFI_editingNewRecord) {
		    successP = @call self::MSG_FFD_RECORD_CONTROL(
						FFRCR_CREATE_NEW_RECORD, 0);
		}
		else {
	            /* Make the given record the current database record. */	
	            successP = FFDRCGotoRecord (oself, rcpRequest,
					FFD_CURRENT_RECORD(pself),
					TRUE, CRT_REGULAR_COMMIT, 
					ERT_REGULAR, TRUE);
		}
	    }
	    break;

	case FFRCR_CREATE_NEW_RECORD:
	    /* Already have maximum number of records?	*/
	    if (MAX_NUM_RECORDS <= pself->FFI_totalNumRecordsInDatabase)
		{
		/* Can't add any new records.	*/
		pself->FFI_numRecords = MAX_NUM_RECORDS;
		pself->FFI_totalNumRecordsInDatabase = MAX_NUM_RECORDS;
		}
	    else
		{
		/* If there are no fields, do nothing */
		if (pself->FFI_numInLayoutNameList != 0)
		    {
		    /* Commit the current temporary record.	*/
		    if (INSERT_FAILED != @call oself::
				MSG_FFD_COMMIT_TEMP_DATA_ROW_TO_DATABASE
					(TRUE, CRT_REGULAR_COMMIT))
		        {
			/*
			 * If automatic marking is on, mark the record
			 * as is appropriate.
			 */
			pself = ObjDerefGen(oself);
			FFDRCAutoMark(oself, pself->SSI_active.CR_row);
			 
			/* Inserted okay so let's edit a new record.	*/
		        @call oself::MSG_FFD_EDIT_NEW_RECORD
					(TRUE, NRT_REGULAR, TRUE);

		        /* Signal success.	*/
		        successP = editNewRecordP = TRUE;
		        }
		    }
		}
	    break;

	case FFRCR_COMMIT_CURRENT_RECORD:
	    /* Commit the current temporary record.	*/
	    if (INSERT_FAILED != @call oself::
			MSG_FFD_COMMIT_TEMP_DATA_ROW_TO_DATABASE
				(TRUE, CRT_REGULAR_COMMIT)) {
		/*
		 * If automatic marking is on, mark the record
		 * as is appropriate.
		 */
		pself = ObjDerefGen(oself);
		FFDRCAutoMark(oself, pself->SSI_active.CR_row);

		/*
		 * If we're showing only marked records and the record
		 * we just commited is no longer marked, jump to the
		 * closest marked record.  We can do this by simply
		 * recalling FFDSubsetShowOnlyMarkedRecords and
		 * leaving.
		 */
		pself = ObjDerefGen (oself);
		if (pself->FFI_showOnlyMarked) {
		    if (! FFDGetRecordMarkStatus(pself,
						 pself->SSI_active.CR_row)) {
			return (FFDSubsetShowOnlyMarkedRecords(oself));
		    }
		}

		/* Signal success.	*/
		successP = TRUE;
	    }
	    break;

	case FFRCR_REVERT_CURRENT_RECORD:
	    /* Revert the current record.	*/
	    successP = @call oself::MSG_FFD_REVERT_CURRENT_RECORD();
	    break;

	case FFRCR_DELETE_CURRENT_RECORD:
	    /* Delete the current record. */
	    if (!FFDRCDeleteRecord (oself, rcpRequest)) {
		/*
		 * We were in showOnlyMarked mode and the last marked record
		 * was deleted.  Switch over to show all records mode.
		 */
		return (@call oself::MSG_FFD_SUBSET_SHOW_ALL_RECORDS());
	    }
	    successP = TRUE;
	    break;

	case FFRCR_GOTO_FIRST_RECORD:
	    if (pself->FFI_showOnlyMarked) {
		if ((pself->FFI_currentMarkedRecord == 0) && 
			(!pself->FFI_editingNewRecord)) {
		    return(TRUE);
		}
	    }
	    else {
		if ((pself->SSI_active.CR_row == 0) &&
			(!pself->FFI_editingNewRecord)) {
		    return(TRUE);
		}
	    }
	    successP = FFDRCRecordMovement(oself, rcpRequest, data);
	    break;

	case FFRCR_GOTO_PREVIOUS_RECORD:
	    /*
	     * If we're already on the first record, do nothing
	     */
	    if (pself->FFI_showOnlyMarked) {
		if (pself->FFI_currentMarkedRecord == 0) {
		    return(TRUE);
		}
	    }
	    else {
		if (pself->SSI_active.CR_row == 0) {
		    return(TRUE);
		}
	    }
	    successP = FFDRCRecordMovement(oself, rcpRequest, data);
	    break;

	case FFRCR_GOTO_NEXT_RECORD:
	    /*
	     * If we're already on the last record, do nothing
	     */
	    if (pself->FFI_showOnlyMarked) {
	        if (pself->FFI_currentMarkedRecord == 
			(pself->FFI_numMarkedRecords - 1)) {
		    return(TRUE);
	        }
	    }
	    else {
	        if (pself->SSI_active.CR_row ==
			(pself->FFI_totalNumRecordsInDatabase - 1)) {
		    return(TRUE);
	        }
	    }
	    successP = FFDRCRecordMovement(oself, rcpRequest, data);
	    break;

	case FFRCR_GOTO_LAST_RECORD:
	    /*
	    * If we're already on the last record, do nothing
	    */
	    if (pself->FFI_showOnlyMarked) {
	        if ((pself->FFI_currentMarkedRecord == 
			(pself->FFI_numMarkedRecords - 1)) &&
			(!pself->FFI_editingNewRecord)) {
		    return(TRUE);
	        }
	    }
	    else {
	        if ((pself->SSI_active.CR_row ==
			(pself->FFI_totalNumRecordsInDatabase - 1)) &&
			(!pself->FFI_editingNewRecord)) {
		    return(TRUE);
	        }
	    }
	    successP = FFDRCRecordMovement(oself, rcpRequest, data);
	    break;

	case FFRCR_GOTO_RECORD:
	    successP = FFDRCRecordMovement(oself, rcpRequest, data);
	    break;

	case FFRCR_MARK_CURRENT_RECORD:
	    FFDSetRecordMarkStatus (pself, TEMP_DATA_ROW, TRUE);
	    pself->FFI_dirtyRecord = successP = TRUE;
	    break;
		
	case FFRCR_UNMARK_CURRENT_RECORD:
	    FFDSetRecordMarkStatus (pself, TEMP_DATA_ROW, FALSE);
	    pself->FFI_dirtyRecord = successP = TRUE;
	    break;
		
	case FFRCR_DIRTY_CURRENT_RECORD:
	    /* Mark the record as being dirty.	*/
	    pself->FFI_dirtyRecord = successP = TRUE;
	    break;

	case FFRCR_CLEAN_CURRENT_RECORD:
	    /* Mark the record as being clean.	*/
	    pself->FFI_dirtyRecord = FALSE;
	    successP = TRUE;
	    break;
	}

    /*
     * Build the RCP status block.
     * Is this a 'new' record?
     */
    pself = ObjDerefGen (oself);
    if ((editNewRecordP) ||
	(pself->FFI_editingNewRecord) ||
	((0 == pself->SSI_active.CR_row) &&
	 (0 == pself->FFI_totalNumRecordsInDatabase)))
	{
	/* Yep.	*/
	FFRCPSMB_NEW_RECORD (ffrcpsmb,
			     pself->FFI_numRecords,
			     pself->FFI_dirtyRecord,
			     !successP,
			     FFDGetRecordMarkStatus(pself, TEMP_DATA_ROW),
			     pself->FFI_showOnlyMarked);
	}
    else {
	/*
	 * It's not a new record.  Set the data.
	 */
	curRecord = pself->FFI_showOnlyMarked ?
	    	    	pself->FFI_currentMarkedRecord :
			pself->SSI_active.CR_row;
	
	FFRCPSMB_SET_DATA (ffrcpsmb,
			   curRecord,
			   pself->FFI_numRecords,
			   FALSE,
			   pself->FFI_dirtyRecord,
			   !successP,
			   FALSE,
			   FFDGetRecordMarkStatus(pself, TEMP_DATA_ROW),
			   pself->FFI_showOnlyMarked,
			   FALSE,
			   FALSE);
	}

    /* Notify the Record Control Panel.	*/
    if (successP) {
	FFDSendRCPNotification (oself, &ffrcpsmb);
    }

    /*
     * Reset the page number.
     */
    numRecordsPerPage = FFDCalculateNumRecordsPerPage(oself, 0, 0);

    pself = ObjDerefGen(oself);
    if (numRecordsPerPage) {
	pself->FFI_currentPage = FFD_CURRENT_RECORD(pself) / numRecordsPerPage;
    } else {
	EC_ERROR(ABOUT_TO_DIVIDE_BY_ZERO);
	pself->FFI_currentPage = 1;
    }

    /*
     * Did the page number change?  If so, reset the page number
     * fields.
     */
    if (successP && pself->FFI_editingNewRecord)
	{
	FFDUpdatePageNumbers (oself);
	}
    else if (successP && (pself->FFI_currentPage != startingPage))
	{
	/*
	 * We must be displaying a new page of records in multi-record
	 * mode.  Tell all page number fields to update themselves.
	 */
	FFDUpdatePageNumbers (oself);
	}

    /*
     * If we're in multi-record, we want to scroll to the current GrObj
     * body. Get the new bounds for the GrObjBody.
     */

    if (pself->FFI_currentLayoutType == LT_MULTI_RECORD)
	{
	FFDScrollToCurrentRecord (oself);
	}

    /*
     * Make sure we -- and not the RCP -- have the focus.
     */
    event = @record GenPrimaryClass::MSG_META_GRAB_FOCUS_EXCL();
    @send oself::MSG_VIS_VUP_SEND_TO_WIN_GROUP (event);

    /* Inform caller of outcome. */
    return (successP);
}	/* End of MSG_FFD_RECORD_CONTROL.	*/

/***********************************************************************
 *
 * FUNCTION:	FFDRCRecordMovement
 *
 * DESCRIPTION:	This function scrolls to the active record; i.e. makes
 *		sure that it's displayed on screen.
 *
 * PARAMETERS:	oself - an optr to the current database.
 *		rcpRequest - valid rcpRequest (see MSG_FFD_RECORD_CONTROL)
 *		newRecord - record to go to if this is a GO_TO_RECORD
 *
 *		returns: TRUE if operation successful; FALSE otherwise
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	11/10/92	Initial version
 *
 ***********************************************************************/
Boolean
FFDRCRecordMovement(optr oself,
		 FFRecordControlRequest rcpRequest,
		 word newRecord)
{
    FlatFileDatabaseInstance *pself;
    EventHandle event;

    pself = ObjDerefGen(oself);

    /*
     * If we're in multi-record data entry, and we're moving
     * off a new record that we haven't dirtied, then we want
     * the screen to be redrawn, because we don't want the
     * old template to be lying around.
     */
    if ((LT_MULTI_RECORD == pself->FFI_currentLayoutType) &&
	(!pself->FFI_dirtyRecord) &&
	(pself->FFI_editingNewRecord)) {
               event = @record GenViewClass::MSG_GEN_VIEW_REDRAW_CONTENT();
               @send oself::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS (event);
	}

    /* Make the given record the current database record.	*/
    return(FFDRCGotoRecord (oself,
			    rcpRequest,
			    newRecord,
			    TRUE,
			    CRT_REGULAR_COMMIT,
			    ERT_REGULAR,
			    TRUE));
}

/***********************************************************************
 *
 * FUNCTION:	FFDScrollToCurrentRecord
 *
 * DESCRIPTION:	This function scrolls to the active record; i.e. makes
 *		sure that it's displayed on screen.
 *
 * PARAMETERS:	oself - an optr to the current database.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	11/10/92	Initial version
 *
 ***********************************************************************/
void
FFDScrollToCurrentRecord(optr oself)
{
    EventHandle event;
    optr grObjBody;
    FlatFileDatabaseInstance *pself;
    RectDWord recordLayoutBounds;
    word numHorizontalRecords, numVerticalRecords, newRecord;

    pself = ObjDerefGen(oself);

    /*
     * Which record are we editing?
     */
    if (pself->FFI_editingNewRecord) {
	newRecord = -1;
    }
    else {
	if (pself->FFI_showOnlyMarked) {
	    newRecord = pself->FFI_currentMarkedRecord;
	}
	else {
	    newRecord = pself->SSI_active.CR_row;
	}
    }

    (void) FFDCalculateNumRecordsPerPage(oself, &numHorizontalRecords,
					 &numVerticalRecords);

    pself = ObjDerefGen(oself);
    grObjBody = @call oself::MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT(
				pself->FFI_currentLayout,
				LT_SINGLE_RECORD);

    FFDCalculateBoundsForActiveRecord(oself, grObjBody, newRecord,
					numHorizontalRecords,
					numVerticalRecords,
					&recordLayoutBounds);

    /* Make sure we scroll to this record */
    event = @record GenViewClass::MSG_GEN_VIEW_MAKE_RECT_VISIBLE(
				0, MRVM_50_PERCENT, 
				0, MRVM_50_PERCENT,
				recordLayoutBounds.RD_bottom,
				recordLayoutBounds.RD_right,
				recordLayoutBounds.RD_top,
				recordLayoutBounds.RD_left);

    @send oself::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);
}


/***********************************************************************
 *
 * FUNCTION:	FFDUpdatePageNumbers
 *
 * DESCRIPTION:	This function tells all the page number fields in the
 *	    	current multi-record layout to update themselves.
 *
 * PARAMETERS:	oself - an optr to the current database.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	9/17/92		Initial version
 *
 ***********************************************************************/
void
FFDUpdatePageNumbers(optr oself)
{
    FlatFileDatabaseInstance *pself;
    optr grobjBody;
    word axr, cxr, dxr, bpr;

    pself = ObjDerefGen(oself);
    grobjBody = @call oself::
	MSG_FFD_GET_GROBJ_BODY_FOR_LAYOUT(pself->FFI_currentLayout,
					  LT_MULTI_RECORD);

    ObjLockObjBlock(OptrToHandle(grobjBody));

    /*
     * Tell all of the page numbers to update themselves.
     */
    GrObjBodyProcessAllGrObjsInDrawOrderCommon(
        grobjBody, OCCT_SAVE_PARAMS_DONT_TEST_ABORT,
        MSG_FFTFG_UPDATE_PAGE_NUMBER, 0, 0, 0,
	&axr, &cxr, &dxr, &bpr);

    MemUnlock(OptrToHandle(grobjBody));
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDDeleteRecordOnMultiRecordLayout
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	On a multi-record layout, after we delete a record, we
		want to redraw all subsequent records ("scroll them up").

CALLED BY:	Internal -- FFRCDeleteRecord.

PASS:		optr	oself		= Current database.

RETURN:		nothing

PSEUDO CODE/STRATEGY:
REQUIRES:	????

ASSERTS:	????

CHECKS:		None.

KNOWN DEFECTS/SIDE EFFECTS/CAVEATS/IDEAS:

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	AML	92.09.22	Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
void
FFDDeleteRecordOnMultiRecordLayout (optr oself)
{
    FlatFileDatabaseInstance *pself = ObjDerefGen(oself);
    optr grObjBody;
    word numRecordsOnPage, numHorizontalRecords, numVerticalRecords;
    GStateHandle gstate;
    LayoutSize recordLayoutBounds;
    EventHandle event;

    grObjBody = FFDGetGrObjBodyForLayout(oself, pself->FFI_currentLayout,
					LT_SINGLE_RECORD);

    numRecordsOnPage = FFDCalculateNumRecordsPerPage(oself, 
						     &numHorizontalRecords, 
						     &numVerticalRecords);

    FFDCalculateBoundsForActiveRecordAndSetGrObjBody(oself, grObjBody,
						FFD_CURRENT_RECORD(pself),
						numHorizontalRecords,
						numVerticalRecords);

    /*
     * Are we editing a new record? If so, invalidate the record layout
     * grobjbody
     */
    pself = ObjDerefGen(oself);
    if (pself->FFI_editingNewRecord) {
	if (pself->FFI_showOnlyMarked) {
	    pself->FFI_currentMarkedRecord = pself->FFI_numMarkedRecords-1;
	    pself->SSI_active.CR_row = FFDGetNthMarkedRecord(oself,
					pself->FFI_numMarkedRecords);
	}
	else {
	    pself->SSI_active.CR_row = 
				pself->FFI_totalNumRecordsInDatabase-1;
	}
	@call oself::MSG_FFD_EDIT_EXISTING_RECORD
				(FFD_CURRENT_RECORD(pself), FALSE, TRUE,
				 ERT_REGULAR);

        event = @record GenViewClass::MSG_GEN_VIEW_REDRAW_CONTENT();
        @send oself::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);
    }

    /*
     * Did we delete the last record? If so, just invalidate the record
     * layout grobjbody.
     */
    pself = ObjDerefGen(oself);
    if (pself->FFI_showOnlyMarked) {
	if (FFDGetNextMarkedRecord(oself, pself->SSI_active.CR_row) ==
	    NOT_A_RECORD) {
            event = @record GenViewClass::MSG_GEN_VIEW_REDRAW_CONTENT();

            @send oself::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);
	}
	else {
	    if ((pself->FFI_currentMarkedRecord / numRecordsOnPage) ==
		((pself->FFI_numMarkedRecords - 1) / numRecordsOnPage)) {
                event = @record GenViewClass::MSG_GEN_VIEW_REDRAW_CONTENT();

                @send oself::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);

	    }
	}
    } 
    else {
	if (pself->SSI_active.CR_row ==
	       pself->FFI_totalNumRecordsInDatabase) {
	    @call grObjBody::MSG_VIS_INVALIDATE();
        }
        else {
	    /*
	     * If we actually need to erase a GrObjBody (if we are on the last
	     * page), then redraw the whole view
	     */
	    if ((pself->SSI_active.CR_row / numRecordsOnPage) ==
			((pself->FFI_numRecords - 1) / numRecordsOnPage)) {
                event = @record GenViewClass::MSG_GEN_VIEW_REDRAW_CONTENT();

                @send oself::MSG_VIS_VUP_CALL_OBJECT_OF_CLASS(event);
	    }
	    else {
	        gstate = @call oself::MSG_VIS_VUP_CREATE_GSTATE();
  	        FFDGetSingleRecordBounds(oself, &recordLayoutBounds);

                FFDDrawMultiRecordDataEntryGrid(oself, 0, gstate,
					recordLayoutBounds,
				        grObjBody,
					numHorizontalRecords,
				        numVerticalRecords,
				        pself->SSI_active.CR_row);
	        GrDestroyState(gstate);
	    }
        }
    }
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDRCDeleteRecord
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Delete the specified record from the database.

CALLED BY:	Internal -- MSG_FFD_RECORD_CONTROL.

PASS:		optr	oself		= Current database.
		FFRecordControlRequest	rcpRequest	= Record control
							  deletion command.

RETURN:		Boolean	= TRUE iff operation is successful or user aborts.
			  FALSE if we were in showOnlyMarked mode and the
			  last marked record was deleted.

PSEUDO CODE/STRATEGY:
	Confirm the delete operation with the user.
	If use says no then
		Abort operation.
	Otherwise,
		If currently editing a new record then
			Move to the last record in the database.
		Otherwise,
			Delete the currrent record from the database.
			If there are no records left in the database then
				Edit a 'new'/empty record.
			Otherwise,
				Edit the new current record.
REQUIRES:	????

ASSERTS:	????

CHECKS:		None.

KNOWN DEFECTS/SIDE EFFECTS/CAVEATS/IDEAS:
	NOTE:	This routine does *not* yet handle the delete all records
		or delete specific (non-current) record functions.

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	JDM	92.07.21	Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

static _pascal Boolean FFDRCDeleteRecord
			(optr oself,
			 FFRecordControlRequest rcpRequest)
{
    TCHAR	*dialogString;
    InteractionCommand		usdReply;
    FlatFileDatabaseInstance	*pself;

    /*
     * Verfiy the operation with the user.
     * First, get access to the user message string.
     */
    MemLock (OptrToHandle (@FFConfirmDeleteRecordString));
    dialogString = LMemDeref (@FFConfirmDeleteRecordString);

    /* Find out what the user wants to do.	*/
    usdReply = UserStandardDialog
    	    	((TCHAR *) 0,	/* No help context	*/
    	    	 (TCHAR *) 0, 	/* No custom responses.	*/
		 (TCHAR *) 0,		/* No arguments.	*/
		 (TCHAR *) 0,
		 dialogString,		/* User prompt string.	*/
		 ((GIT_AFFIRMATION << CDBF_INTERACTION_TYPE_OFFSET) |
		  (CDT_QUESTION << CDBF_DIALOG_TYPE_OFFSET)));

    /* Get rid of the string block.	*/
    MemUnlock (OptrToHandle (@FFConfirmDeleteRecordString));

    /* User wants to bail?	*/
    if (IC_NO == usdReply)
	{
	/* Yep.  Don't delete.	*/
	return (TRUE);
	}

    /* Currently editing a new record?	*/
    pself = ObjDerefGen (oself);
    if (pself->FFI_editingNewRecord)
	{
	/* Yep.  Any records to display?	*/
	if (pself->FFI_numRecords) 
	    {
	    /*
	     * Are we in multi-record data entry mode?
	     * If yes, we want to "scroll" up the remaining records on the
	     * page.
	     */
	    if ((pself->FFI_currentMode == MT_DATA_ENTRY) &&
		(pself->FFI_currentLayoutType == LT_MULTI_RECORD))
		{
		FFDDeleteRecordOnMultiRecordLayout(oself);
		}
	    else
		{
		/* Yep.  Move to the last record in the database.	*/
		@call oself::MSG_FFD_EDIT_EXISTING_RECORD
				(pself->FFI_numRecords-1, FALSE, TRUE,
					ERT_REGULAR);
		}
	    }
	else
	    {
	    /* Nope.  Just clear out the new record.	*/
	    @call oself::MSG_FFD_EDIT_NEW_RECORD (FALSE, NRT_REGULAR, TRUE);
	    }
	}
    else
	{
	/* Nope.  Nuke the current record.	*/
	@call oself::MSG_FFD_DELETE_CURRENT_RECORD ();

	pself = ObjDerefGen(oself);
	if (!pself->FFI_showOnlyMarked) {
	    /*
	     * We're showing all records.
	     */
	    if (!pself->FFI_numRecords) {
		/* Is this the last record? Then edit a new record.	*/
		@call oself::MSG_FFD_EDIT_NEW_RECORD (FALSE, NRT_REGULAR, TRUE);
	    } else {
		/*
		 * Are we in multi-record data entry mode?
		 * If yes, we want to "scroll" up the remaining records on the
		 * page.
		 */
		if ((pself->FFI_currentMode == MT_DATA_ENTRY) &&
		    (pself->FFI_currentLayoutType == LT_MULTI_RECORD)) {
		    FFDDeleteRecordOnMultiRecordLayout(oself);
		} else {
		    @call oself::MSG_FFD_EDIT_EXISTING_RECORD
			(pself->SSI_active.CR_row, FALSE, TRUE, ERT_REGULAR);
		}
	    }
	} else {
	    /*
	     * We're showing only marked records.
	     */
	    if (!pself->FFI_numMarkedRecords) {
		/*
		 * We just deleted the last marked record.  Send a flag
		 * indicating that we should switch over to show all
		 * records.
		 */
		return FALSE;
	    }
	    else {
		/*
		 * There are still marked records around.
		 *
		 * Are we in multi-record data entry mode?
		 * If yes, we want to "scroll" up the remaining records on the
		 * page.
		 */
		if ((pself->FFI_currentMode == MT_DATA_ENTRY) &&
		    (pself->FFI_currentLayoutType == LT_MULTI_RECORD)) {
		    FFDDeleteRecordOnMultiRecordLayout(oself);
		}
		else {
		    /*
		     * We are NOT in multi-record mode.  Display the next
		     * marked record.
		     */
		    FieldID colNum = FFDGetNthMarkedRecord(oself,
					  pself->FFI_currentMarkedRecord + 1);

		    @call oself::MSG_FFD_EDIT_EXISTING_RECORD
			(colNum, FALSE, TRUE, ERT_REGULAR);
		}
	    }
	}
    }

    /* We made it!  Signal success.	*/
    return (TRUE);
}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDCalculateBoundsForActiveRecord
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Assumes we're in multi-record data entry mode. Given
		the current record, as well as the number of horizontal
		and vertical records on the page, this routine calculates
		the bounds of the record layout for this record.

CALLED BY:	Internal -- FFDCalculateBoundsForActiveRecordAndSetGrObjBody
				FFD_RECORD_CONTROL

PASS:		optr	oself		= Current database.
		optr 	grObjBody	= optr to body of the record layout.
		word	newRecord	= what you'd think 
		word	numHorizontalRecords, numVerticalRecords =
					the number of horizontal and 
					vertical records that fit within
					the page repeater box of the page
					layout.

RETURN:		nothing

PSEUDO CODE/STRATEGY:

CHECKS:		None.

KNOWN DEFECTS/SIDE EFFECTS/CAVEATS/IDEAS:	????

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	AML	92.11.10	Broke out into function.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

void
FFDCalculateBoundsForActiveRecord(optr oself, 
				  optr grObjBody,
				  word newRecord,
				  word numHorizontalRecords,
				  word numVerticalRecords,
				  RectDWord *recordLayoutBounds)
{
  LayoutSize recordBounds;
  FlatFileDatabaseInstance *pself;
  word numRecordsPerPage;
  sdword boundaryXCoord, boundaryYCoord;

  numRecordsPerPage = numHorizontalRecords * numVerticalRecords;

  pself = ObjDerefGen(oself);

  /*
   * Is this a new record?
   * If so, place it at the end
   */
  if (newRecord == -1) {
      if (pself->FFI_showOnlyMarked) {
	  newRecord = pself->FFI_numMarkedRecords;
      }
      else {
          newRecord = pself->FFI_numRecords;
      }
  }

  pself->FFI_currentPage = newRecord / numRecordsPerPage;

  /*
   * We are actually interested in the record's position on the page,
   * not its actual record number
   */
  newRecord = newRecord % (numRecordsPerPage);

  FFDGetPageLayoutBoundaryStartingOffset(oself, &boundaryXCoord,
							&boundaryYCoord);

  FFDGetSingleRecordBounds(oself, &recordBounds);
  pself = ObjDerefGen(oself);
  if (pself->FFI_recordOrder == ROO_TOP_TO_BOTTOM) {
    recordLayoutBounds->RD_left = boundaryXCoord +
					(newRecord / numVerticalRecords) * 
					recordBounds.LS_width;
    recordLayoutBounds->RD_top = boundaryYCoord +
					(newRecord % numVerticalRecords) *
					recordBounds.LS_height;
  }
  else {
    recordLayoutBounds->RD_left = boundaryXCoord +
					(newRecord % numHorizontalRecords) * 
					recordBounds.LS_width;
    recordLayoutBounds->RD_top = boundaryYCoord +
					(newRecord / numHorizontalRecords) *
					recordBounds.LS_height;
  }

  recordLayoutBounds->RD_right = recordLayoutBounds->RD_left + 
					recordBounds.LS_width;
  recordLayoutBounds->RD_bottom = recordLayoutBounds->RD_top + 
					recordBounds.LS_height;
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDCalculateBoundsForActiveRecordAndSetGrObjBody
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Assumes we're in multi-record data entry mode. Given
		the current record, as well as the number of horizontal
		and vertical records on the page, this routine calculates
		the bounds of the record layout for this record.
		It then sets the bounds of the GrObjBody as appropriate.

CALLED BY:	Internal -- FFDRCMoveGrObjBodyForMultiRecDataEntry

PASS:		optr	oself		= Current database.
		optr 	grObjBody	= optr to body of the record layout.
		word	newRecord	= what you'd think 
		word	numHorizontalRecords, numVerticalRecords =
					the number of horizontal and 
					vertical records that fit within
					the page repeater box of the page
					layout.

RETURN:		nothing

PSEUDO CODE/STRATEGY:

CHECKS:		None.

KNOWN DEFECTS/SIDE EFFECTS/CAVEATS/IDEAS:	????

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	AML	92.09.15	Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

void
FFDCalculateBoundsForActiveRecordAndSetGrObjBody(optr oself, 
						 optr grObjBody,
						 word newRecord,
						 word numHorizontalRecords,
						 word numVerticalRecords)
{
  RectDWord recordLayoutBounds;

  FFDCalculateBoundsForActiveRecord(oself, grObjBody, newRecord,
					numHorizontalRecords,
					numVerticalRecords,
					&recordLayoutBounds);

  /* Set the new bounds for the GrObjBody */
  @call grObjBody::MSG_GB_SET_BOUNDS(&recordLayoutBounds);
}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDRCMoveGrObjBodyForMultiRecDataEntry
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Check if we're in multi-record data entry mode. If we 
		are, and the current record moves to a record already 
		displayed on this page, then just move the GrObjBody 
		over and set a flag that no more needs to be done. If 
		the record we're moving to is on another page, then a 
		"redraw screen" command will be given at the end of
    		the method handler that called this (MSG_FFD_RECORD_CONTROL).

CALLED BY:	Internal -- MSG_FFD_RECORD_CONTROL.

PASS:		optr	oself		= Current database.
		word	newRecord	= what you'd think 
		Boolean *stayOnThisPage = gets set to TRUE iff the
					record we're moving to
					is on the same page as the
					current record. Else FALSE.

RETURN:		nada

PSEUDO CODE/STRATEGY:

CHECKS:		None.

KNOWN DEFECTS/SIDE EFFECTS/CAVEATS/IDEAS:	????

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	AML	92.09.15	Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
void
FFDRCMoveGrObjBodyForMultiRecDataEntry(optr oself, word newRecord,
				       Boolean *stayOnThisPage)
{
  word	numRecordsOnPage, numHorizontalRecords, numVerticalRecords;
  optr grObjBody;
  GStateHandle gstate;
  FlatFileDatabaseInstance *pself;

  /*
   * Check if we're in multi-record data entry mode. If we are, and
   * the current record moves to a record already displayed on this
   * page, then just move the GrObjBody over and set a flag that no
   * more needs to be done. If the record we're moving to is on another
   * page, then a "redraw screen" command will be given at the end of
   * the method handler that called this (MSG_FFD_RECORD_CONTROL).
   */

  /* Assume we're going to stay on this page */
  *stayOnThisPage = TRUE;

  pself = ObjDerefGen(oself);
  if ((pself->FFI_currentLayoutType == LT_MULTI_RECORD) &&
		(pself->FFI_currentMode == MT_DATA_ENTRY)) {

    /* Calculate the number of records on this page */
    numRecordsOnPage = FFDCalculateNumRecordsPerPage(oself, 
						     &numHorizontalRecords, 
						     &numVerticalRecords);

    /*
     * Are we using marked records? Then figure out the position of this
     * record
     */
    pself= ObjDerefGen(oself);

    if (pself->FFI_showOnlyMarked) {
	if (newRecord == pself->FFI_totalNumRecordsInDatabase) {
	    /* This is a new record; it will be at the end */
	    newRecord = pself->FFI_numMarkedRecords;
	}
	else {
	    newRecord = FFDDetermineMarkedPosition(oself, newRecord) - 1;
	}
    }

    pself = ObjDerefGen(oself);

    if ((newRecord / numRecordsOnPage) == pself->FFI_currentPage) {
      /* 
       * Stay on the page; move the GrObjBody over!! 
       * First, get the optr to the grobjbody
       */
      grObjBody = FFDGetGrObjBodyForLayout(oself, pself->FFI_currentLayout,
					      LT_SINGLE_RECORD);

      /* 
       * Erase the rectangle around the old record
       */
      gstate = @call oself::MSG_VIS_VUP_CREATE_GSTATE();

      if (numRecordsOnPage > 1) {
        FFDDrawRecordLayoutBoundaryForMultiRecord(gstate, 0, grObjBody);
      }
      GrDestroyState(gstate);

      /*
       * Calculate and set the new bounds for the body
       */
      FFDCalculateBoundsForActiveRecordAndSetGrObjBody(oself, grObjBody,
							newRecord,
							numHorizontalRecords,
						        numVerticalRecords);

      /* 
       * Now draw a rectangle around the new record  
       */
      gstate = @call oself::MSG_VIS_VUP_CREATE_GSTATE();

      if (numRecordsOnPage > 1) {
        FFDDrawRecordLayoutBoundaryForMultiRecord(gstate, 0, grObjBody);
      }

      GrDestroyState(gstate);
    }
    else {
      /* do nothing except flag, the caller of this routine will handle it */
      *stayOnThisPage = FALSE;
    }
  }
}

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDRCGetNewRecord
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Based on the rcpRequest, calculate the new record and
		return its absolute row number.

CALLED BY:	Internal -- FFDRGotoRecord.

PASS:		optr	oself		= Current database.
		FFRecordControlRequest	rcpRequest	= Record control
							  navigation
							  command function.
		word	newRecord	= Used iff FFRCR_GOTO_RECORD.

RETURN:		word	= new record number.

PSEUDO CODE/STRATEGY:

CHECKS:		None.

KNOWN DEFECTS/SIDE EFFECTS/CAVEATS/IDEAS:	????

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	AML	92.09.15	Initial version.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
word
FFDRCGetNewRecord (optr oself,
		   FFRecordControlRequest rcpRequest,
		   word newRecord)
{
    word	curRecord;
    word	numRecords;
    FlatFileDatabaseInstance *pself;
    
    pself = ObjDerefGen(oself);
    
    /*
     * If we're only showing marked records, call another routine.
     */
    if (pself->FFI_showOnlyMarked) {
	return FFDRCGetNewMarkedRecord(oself, rcpRequest, newRecord);
    }

    /* Otherwise figure out which record to make the new current record. */
    curRecord = pself->SSI_active.CR_row;
    numRecords = pself->FFI_totalNumRecordsInDatabase;

    switch (rcpRequest) {
    	case FFRCR_GOTO_FIRST_RECORD:
	    newRecord = 0;
	    break;

	case FFRCR_GOTO_PREVIOUS_RECORD:
	    /* Editing a new record?	*/
	    if (pself->FFI_editingNewRecord) {
		/* Yep.  So make the old last record the current record. */
		newRecord = (numRecords) ? numRecords - 1 : 0;
	    } else {
		/* Nope.  So just move to the previous record (if any).	*/
		newRecord = (curRecord) ? curRecord - 1 : 0;
	    }
	    break;

	case FFRCR_GOTO_NEXT_RECORD:
	    /* Editing a new record?	*/
	    if ((pself->FFI_editingNewRecord) && 
			(pself->FFI_currentLayoutType == LT_SINGLE_RECORD)) {
		/* Yep.  This shouldn't happen for single records!  
		   Do something safe. */
	    	newRecord = numRecords - 1;
	    } else {
		/* Nope.  So just move to the next record (if any). */
		newRecord = (curRecord == numRecords - 1) ?
		    	     	    	    	curRecord : curRecord + 1;
	    }
	    break;

	case FFRCR_GOTO_LAST_RECORD:
	    newRecord = numRecords - 1;
	    break;

	case FFRCR_GOTO_RECORD:
	    break;		/* newRecord already set. */

    	case FFRCR_REFRESH:
	    newRecord = curRecord;
	    break;
    }
    
    return(newRecord);
}


/***********************************************************************
 *
 * FUNCTION:	FFDRCGetNewMarkedRecord
 *
 * DESCRIPTION:	Based on the rcpRequest, calculate the new marked record and
 *	    	return its absolute row number.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	rcpRequest - RCP navigation command
 *	    	newRecord - used with FFRCR_GOTO_RECORD.
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	1/12/93		Initial version
 *
 ***********************************************************************/
word
FFDRCGetNewMarkedRecord(optr oself,
			FFRecordControlRequest rcpRequest,
			word newRecord)
{
    word	curRecord;
    word    	numMarkedRecords;
    FlatFileDatabaseInstance *pself;
    
    pself = ObjDerefGen(oself);
    
    /*
     * Figure out which marked record to make the new current record.
     */
    curRecord = pself->SSI_active.CR_row;
    numMarkedRecords = pself->FFI_numMarkedRecords;

    switch (rcpRequest) {
    	case FFRCR_GOTO_FIRST_RECORD:
	    newRecord = FFDGetFirstMarkedRecord(oself);
	    break;

	case FFRCR_GOTO_PREVIOUS_RECORD:
	    /*
	     * If we're editing a new record, make the previous record
	     * be the last marked record in the database.  Else, just get
	     * the previous record from the current spot.
	     */
	    if (pself->FFI_editingNewRecord) {
		newRecord = FFDGetNthMarkedRecord(oself, numMarkedRecords);
						  
	    } else {
		newRecord = FFDGetPreviousMarkedRecord(oself, curRecord);
	    }
	    break;

	case FFRCR_GOTO_NEXT_RECORD:
	    newRecord = FFDGetNextMarkedRecord(oself, curRecord);
	    break;

	case FFRCR_GOTO_LAST_RECORD:
	    newRecord = FFDGetNthMarkedRecord(oself, numMarkedRecords);
	    break;

	case FFRCR_REFRESH:
	case FFRCR_GOTO_RECORD:
	    /*
	     * Get the Nth marked record.  (N - 1) is passed in newRecord.
	     */
	    newRecord = FFDGetNthMarkedRecord(oself, newRecord + 1);
	    break;
    }
    
    return(newRecord);
}

/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GET_NUMBER_OF_PAGES for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message returns the total number of pages printable
 *	    	from the current layout.
 *
 *	    	If we're in design mode, 0 will be returned.
 *
 * PARAMETERS:
 *	word ()
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	10/13/92	Initial version
 *
 ***********************************************************************/
@extern method FlatFileDatabaseClass, MSG_FFD_GET_NUMBER_OF_PAGES
{
    word numRecordsPerPage, numRecords;
    word numPages;

    /*
     * If we're not in data entry mode, indicate that there are no
     * pages at all.
     */
    if (pself->FFI_currentMode & MT_DESIGN) {
	return 0;
    }

    numRecords = pself->FFI_numRecords;
    numRecordsPerPage = FFDCalculateNumRecordsPerPage(oself, NULL, NULL);
    numPages = FFD_div_ceil(numRecords, numRecordsPerPage);

    return numPages;
}


/***********************************************************************
 *
 * MESSAGE:	MSG_FFD_GO_TO_PAGE for FlatFileDatabaseClass
 *
 * DESCRIPTION:	This message jumps to the specified page in the current
 *	    	layout.  Note that pages can be different in single-
 *	    	vs. multi-record mode.
 *
 *	    	Pass the page number to jump to.
 *
 * PARAMETERS:
 *	void (word newPage)
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	10/13/92	Initial version
 *
 ***********************************************************************/
@extern method FlatFileDatabaseClass, MSG_FFD_GO_TO_PAGE
{
    word numRecordsPerPage;

    #if ERROR_CHECK
    	if (newPage < 1) {
	    EC_ERROR(BAD_PAGE_NUMBER);
	}
    #endif /* ERROR_CHECK */
    
    /*
     * Set the new page number.
     */
    pself->FFI_currentPage = newPage - 1;

    numRecordsPerPage = FFDCalculateNumRecordsPerPage(oself, NULL, NULL);

    /*
     * Ok then.  We know which page we want, and the number of records
     * that fit per page.  Now jump to the correct record.
     */
    if (FFDRCGotoRecord(oself,
			FFRCR_GOTO_RECORD,
			(word)((newPage - 1) * numRecordsPerPage),
			TRUE,
			CRT_REGULAR_COMMIT,
			ERT_REGULAR,
			TRUE)) {
	/*
	 * We jumped successfully to the new record.  Update page number
	 * fields.
	 */
	FFDUpdatePageNumbers(oself);
    }
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDRCGotoRecord
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Make the specified record the current record in the
		database

CALLED BY:	Internal -- MSG_FFD_RECORD_CONTROL.

PASS:		optr	oself		= Current database.
		FFRecordControlRequest	rcpRequest	= Record control
							  navigation
							  command function.
		word	newRecord	= Used iff FFRCR_GOTO_RECORD.

 		Boolean moveGrObjBody	= When you request
 					an existing record and are 
 					in a multi-record layout,
 					it's possible that the 
 					GrObjBody associated with the new
 					record needs to be moved. If the
 					GrObjBody is not necessarily in
 					the right place, pass TRUE.
		CommitRecordType commitRecordType =
				When we're redrawing multi-record
				mode and currently editing a new
				record, we don't want to commit
				that particular record's data to
				the database while we're redrawing
				other record, though we do want to
				save the new record's data somewhere
				temporarily.
				If this is the case, set 
				commitRecordType = CRT_VISUAL_UPDATE_COMMIT.
				Otherwise, set it to CRT_REGULAR_COMMIT

		EditRecordType editRecordType =
				If the record we want to edit should
				be loaded from the temporary visual
				update row, this should be set to
				ERT_LOAD_FROM_TEMP_VISUAL_UPDATE_ROW.
				For normal behavior, set to ERT_REGULAR.

 		Boolean fieldGrabTarget = TRUE if you want the first field
					  to grab the target & focus. If
					  FALSE, this routine will not muck
					  with targets etc.
					  
RETURN:		Boolean	= TRUE iff operation is successful.
			  FALSE otherwise.

PSEUDO CODE/STRATEGY:
	Commit the current record to the database (if any).
	If the current record has invalid data then
		return error.
	If there are no records then
		Edit a 'new'/empty record.
	Otherwise,
		Figure out which record to go to.
		Make the specified record the new current record in the
		database.

REQUIRES:	????

ASSERTS:	????

CHECKS:		None.

KNOWN DEFECTS/SIDE EFFECTS/CAVEATS/IDEAS:	????

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	JDM	92.07.21	Initial version.
	AML	92.09.11	Added special casing for multi-record
				data entry scenario.
	AML	92.11.11	Added commitRecordType param

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
Boolean
FFDRCGotoRecord (optr oself,
		 FFRecordControlRequest rcpRequest,
		 word newRecord,
		 Boolean moveGrObjBody,
		 CommitRecordType commitRecordType,
		 EditRecordType editRecordType,
		 Boolean fieldGrabTarget) 
{
    FlatFileDatabaseInstance *pself;
    Boolean dirtyRecord;

#if ERROR_CHECK
    /* Make sure we have a proper commitRecordType */
    switch(commitRecordType) {
	case CRT_VISUAL_UPDATE_COMMIT:
	case CRT_REGULAR_COMMIT:
	    break;
	default:
	    EC_ERROR(BAD_COMMIT_RECORD_TYPE);
    }
#endif

    /* Get a hold on ourself.	*/
    pself = ObjDerefGen (oself);

    /* Make sure that there are records to go to.	*/
    if (!pself->FFI_totalNumRecordsInDatabase) {
	/* No records in the database so edit a new record.	*/
	@call oself::MSG_FFD_EDIT_NEW_RECORD (moveGrObjBody, NRT_REGULAR, 
						fieldGrabTarget);
	return (TRUE);
    } else {
	/*
	 * Remember if the record was dirty or not, so we can auto-mark it
	 * if we need to.
	 */
	 
	dirtyRecord = pself->FFI_dirtyRecord;
	
	/*
	 * Commit the current temporary record (if any).
	 */
	if (INSERT_FAILED == @call oself::
			MSG_FFD_COMMIT_TEMP_DATA_ROW_TO_DATABASE(TRUE,
							commitRecordType)) {
	    return (FALSE);		/* Choked and died so bail.	*/
	}

	/*
	 * If automatic marking is on and the record was changed, mark the
	 * record as is appropriate.
	 */
	pself = ObjDerefGen(oself);
	if (dirtyRecord) {
	    FFDRCAutoMark(oself, pself->SSI_active.CR_row);
	}

	/* Where do we go from here.	*/
	newRecord = FFDRCGetNewRecord (oself, rcpRequest, newRecord);

	/* Goto the specified record.	*/
	@call oself::MSG_FFD_EDIT_EXISTING_RECORD(newRecord, moveGrObjBody,
						  fieldGrabTarget,
						  editRecordType);

	/* Signal success.	*/
	return (TRUE);
    }
}	/* End of FFDRCGotoRecord().	*/


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		FFDSendRCPNotification
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SYNOPSIS:	Send the given FFRecordControlStatusMessageBlock to the
		Record Control Panel UI controller.

CALLED BY:	Internal --	MSG_FFD_RECORD_CONTROL.

PASS:		oself			= optr to database
		FFRecordControlStatusMessageBlock *ffrcpsmb
					= pointer to data to send to the Record
					  Control Panel.
RETURN:		Void.

PSEUDO CODE/STRATEGY:
	If the given RCP status message is not marked as being invalid then
		Allocate a RCP status message block to send out with the
		notification.
		Check the allocation for failure.
		Copy the data from the given status block into the just
		allocated block.
	Otherwise,
		Send a null data block handle to signify to the controller
		that it should be disabled.
	Build the classed event to send out.
	Send the classed event out to the process's application
	notification list.

REQUIRES:	????

ASSERTS:	????

CHECKS:		None.

KNOWN DEFECTS/SIDE EFFECTS/CAVEATS/IDEAS:	????

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	JDM	92.07.21	Initial version.
	JDM	92.08.20	Updated for new status flags.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

void _pascal FFDSendRCPNotification
			(optr oself,
			 FFRecordControlStatusMessageBlock *ffrcpsmb)
{
    Message msg;
    MemHandle dataBlockHandle;
    FFRecordControlStatusMessageBlock *dataBlock;

    if (FFRCPSMB_IS_DISABLE_RCP (*ffrcpsmb))
	{
	/*
	 * Use a null data block handle to force the disabling of the
	 * controller.
	 */
	dataBlockHandle = NullHandle;
	}
    else
	{
	/* Allocate the RCP status block.	*/
	dataBlockHandle = MemAlloc
			(sizeof (FFRecordControlStatusMessageBlock),
			 HF_DYNAMIC | HF_SHARABLE,
			 HAF_STANDARD | HAF_NO_ERR);

	/* Copy the given block data into the block to send.	*/
	dataBlock = MemLock (dataBlockHandle);

	dataBlock->curRecord   = ffrcpsmb->curRecord;
	dataBlock->numRecords  = ffrcpsmb->numRecords;
	dataBlock->statusFlags = ffrcpsmb->statusFlags;

	MemUnlock (dataBlockHandle);
	MemInitRefCount (dataBlockHandle, 1);
	}	/* End of else not invalid status message block.	*/

    /* Build the message to send to the Record Control Panel.	*/
    msg = @record FFRecordControlClass::
		MSG_META_NOTIFY_WITH_DATA_BLOCK
				(MANUFACTURER_ID_GEOWORKS,
				 GWNT_FLAT_FILE_RCP_STATUS_CHANGE,
				 dataBlockHandle);

    /* Send the notification up the application tree.	*/
    @call GeodeGetAppObject(0)::MSG_META_GCN_LIST_SEND
		(GCNLSF_SET_STATUS,
		 msg,
		 dataBlockHandle,
		 GAGCNLT_APP_TARGET_NOTIFY_FLAT_FILE_RCP_STATUS_CHANGE,
		 MANUFACTURER_ID_GEOWORKS);
}	/* End of FFDSendRCPNotification().	*/


/***********************************************************************
 *
 * FUNCTION:	FFDRCCreateNewRecordForMultiRecDataEntry
 *
 * DESCRIPTION:	Draw the record layout grobjbody (this is called from
 *		MSG_FFD_RECORD_CONTROL if we want to Create a New
 *		Record in multi-record mode).
 *
 * PARAMETERS:	Pass:	oself - optr to flatfile database object 
 *		
 *		Returns:TRUE if new record is on the current page
 *			FALSE otherwise
 *
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	anna	9/18/92		Initial version
 *
 ***********************************************************************/
Boolean
FFDRCCreateNewRecordForMultiRecDataEntry(optr oself)
{
    FlatFileDatabaseInstance *pself;
    GStateHandle gstate;
    optr recordLayoutGrObjBody;
    word newRecord; 
    Boolean stayOnThisPage;
    RectDWord recordLayoutBounds;

    pself = ObjDerefGen(oself);

    newRecord = pself->FFI_totalNumRecordsInDatabase;

    /*
     * Erase the current "active record" boundary
     */
    gstate = @call oself::MSG_VIS_VUP_CREATE_GSTATE();

    pself = ObjDerefGen(oself);
    recordLayoutGrObjBody = FFDGetGrObjBodyForLayout(oself, 
						pself->FFI_currentLayout,
					     	LT_SINGLE_RECORD);

    FFDRCMoveGrObjBodyForMultiRecDataEntry(oself, newRecord, &stayOnThisPage);

    if (stayOnThisPage) {
        /* @call recordLayoutGrObjBody:: MSG_VIS_MARK_INVALID(
					VOF_WINDOW_INVALID, VUM_NOW); */

	/*
	 * Set the clip rectangle so we don't draw things outside
	 * of the grobj body bounds
	 */
        @call recordLayoutGrObjBody::MSG_GB_GET_BOUNDS(&recordLayoutBounds);

	GrSaveState(gstate);

	GrSetClipRect(gstate, PCT_INTERSECTION, 
			 (word) recordLayoutBounds.RD_left,
			 (word) recordLayoutBounds.RD_top,
			 (word) recordLayoutBounds.RD_right,
			 (word) recordLayoutBounds.RD_bottom);

        @call recordLayoutGrObjBody::MSG_VIS_DRAW(0, gstate);

	GrRestoreState(gstate);

    }
    else {
	/* 
	 * Set the flag saying we're editing a new record.
	 * The flatfile drawing routine needs to know this.
	 */
	pself = ObjDerefGen(oself);
	pself->FFI_editingNewRecord = TRUE;
    }

    GrDestroyState(gstate);

    return(stayOnThisPage);
}


/***********************************************************************
 *
 * FUNCTION:	FFDRCAutoMark
 *
 * DESCRIPTION:	This function marks a record by a certain criteria if
 *	    	the auto-marking flag is set for the current database.
 *
 *	    	If there is no current mark criteria, the field is
 *	    	marked.  If there is a mark criteria (which means if
 *	    	there is an expression defined for marking records),
 *	    	that expression is evaluated on the record to
 *	    	determine whether or not is should be marked.
 *
 * PARAMETERS:	oself - an optr to the current database
 *	    	recordNum - the record to mark automatically
 *	    	
 * CALLED BY:	INTERNAL
 *
 * KNOWN BUGS/SIDE EFFECTS/CAVEATS/IDEAS:
 *
 * REVISION HISTORY:
 *	Name	Date		Description
 *	----	----		-----------
 *	jeremy	2/18/93		Initial version
 *
 ***********************************************************************/
void
FFDRCAutoMark(optr oself, word recordNum)
{
    FlatFileDatabaseInstance *pself = ObjDerefGen(oself);
    byte *tokenStream;
    SubsetEvalResult result;

    /*
     * Are we marking automatically?  If not, bail.
     */
    if (pself->FFI_autoApplyMark == 0) {
	return;
    }

    /*
     * Is there a mark criteria?  If not, just mark the thing and leave.
     */
    tokenStream = ObjVarFindData(oself, FFI_VAR_SUBSET_TOKEN_STREAM);

    if (!tokenStream) {
	/*
	 * There is currently no mark criteria, so just mark the record
	 * and leave.
	 */
    	FFDSetRecordMarkStatus(pself, recordNum, TRUE);
	return;
    }

    /*
     * There is a mark criteria.  Mark the thing as appropriate.
     */
    result = FFDSubsetTestExpression(oself, tokenStream, recordNum);
    
    pself = ObjDerefGen(oself);
    switch (result) {
        case SER_TRUE:
	    /*
	     * We have a winnah.  Set the marked flag for this record.
	     */
	    RowSetFlags(&pself->SSI_cellParams,
			recordNum,
			MARKED_RECORD);
	    RowSetFlags(&pself->SSI_cellParams,
			TEMP_DATA_ROW,
			MARKED_RECORD);
	    break;

	case SER_FALSE:
	    /*
	     * Clear the marked flag.
	     */
	    RowSetFlags(&pself->SSI_cellParams,
			recordNum,
			UNMARKED_RECORD);
	    RowSetFlags(&pself->SSI_cellParams,
			TEMP_DATA_ROW,
			UNMARKED_RECORD);
	    break;
    }

    return;
}
